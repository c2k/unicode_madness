{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 Loli is a embedded programming language. Loli is statically-typed, Loli uses reference counting for memory management with garbage collection as a fallback. Key features of Loli : - Built-in template mode - Embed/extend in C - Single-inheritance classes - Exceptions - Generics - Algebraic data types - Built-in coroutines Syntax overview \u00b6 Declarations \u00b6 Variables must be declared before they are used, with the var keyword: var x = 5 var y: Double = 5.32 var z = [1, 2, 3], hi = \"Hello, world!\" The value used to initialize a variable determines the type of the variable. In most cases, var does not need extra type information. However, sometimes the right side of an initialization doesn't provide enough info and type information must be provided: var some_list: List[Double] = [] Literals \u00b6 Loli has several predefined classes, and syntax for using them as well. Boolean \u00b6 Either true or false . Byte \u00b6 A numeric value from 0 to 255. Can be declared like an Integer but with a suffix of t , or like a String using a single character or escape sequence between single quote marks: 0t 0xFFt 255t 'a' '\\t' ByteString \u00b6 An array of Byte values. A String , but with no guarantees about embedded \\0 values or utf-8. Allows any escape character between quotes: b\"123456\" b\"\\0\\1\\2\" b\"\\255\\254\\t\" b\"\"\"A \\ multi-line \\ ByteString\"\"\" Double \u00b6 0.00000005 -1.7 10e1 5e-5 Hash \u00b6 A Hash is a key to value mapping. Only Integer and String can be used for the key. The value can be anything, so long as there is a consistent type. If a Hash literal contains the same key twice, both values will still be computed if necessary, but the right-most key wins: var a_hash = [\"a\" => 1, \"b\" => 2, \"c\" => 3] var empty_hash: Hash[String, Integer] = [] Integer \u00b6 A 64-bit signed value that can be represented using different bases: 12345 -67890 0c744 x0xFF 0b101010101 List \u00b6 A List is composed of values put together in brackets. The values must have some common type: var a_list = [1, 2, 3] var a_range = range(1, 3) var empty_list: List[Double] = [] String \u00b6 Represents a block of text. String carries the guarantee that all instances are valid utf-8, and that they do not carry \\0 characters inside. String literals are single-line by default, but can be multi-line as well: var hi = \"Hello, world!\" var multi_line = \"\"\"Hello, \\ world!\"\"\" Tuple \u00b6 A Tuple is similar to a List , except that Tuple s have a fixed size, but can hold types that don't have any similarity to each other. A Tuple begins with <[ and ends with ]> : var a_tuple: Tuple[String, Double] = <[\"hi\", 34.93]> Comments \u00b6 There are two kinds of comments: # A single-line comment #[ And a multi-line comment ]# Escape codes \u00b6 String , ByteString , and Byte support the following escape sequences: - \\a : Bell - \\b : Backspace - \\t : Tab - \\n : A newline - \\r : Carriage return - \\\" : The \" character - \\' : The ' character - \\\\ : The \\ character - \\/ : \\ on Windows, / elsewhere. - \\ddd : 'ddd' is up to 3 digits, scanned in decimal. This can yield any value between 0 and 255 inclusive. Scanning stops either after 3 digits have been consumed, or a non-base 10 digit occurs. - \\<newline> : ByteString and String only. The newline of the current line and the leading whitespace ( ' ' or '\\t' ) will be omitted from the literal. Operators \u00b6 Basic arithmatic operations ( + - * / ) can be used for two Double values, or two Integer values, or when there is one Double and one Integer value. The result is a Double if either side is a Double , Integer otherwise. Other primitive operations (shifts, bitwise operations, and modulo) are only valid if both sides are Integer . Comparison \u00b6 Comparison operations ( >= > < <= ) are allowed on any two sets of Integer , String , or Double . Equality operations ( == != ) are allowed on any two equivalent types. Simple values like Integer , and Double are straightforward: They are equal only when they are the same value. List , Tuple , Hash , and variants use structural comparison. All other containers and more interesting types use identity comparison. A comparison such as SomeClass(2, 4) == SomeClass(2, 4) will always return false , since each SomeClass is a different instance. Interpolation \u00b6 The ++ operator and String.format all make use of built-in interpolation. Interpolation works as follows: Primitive values such as Integer , Double , and String have their content written out. Built-in containers have their inner contents written out. Hash does not guarantee an ordering to the contents it writes out. Non-scoped variants print just their name and their contents. Scoped variants print out the enum name and a dot first. Classes print out their address. If \u00b6 if x == 0: { # do something... elif x == 1: # do something another... else: # do something another... } Loops \u00b6 There are while , for and built-in classes' iterators(such as List.each ): var i = 0 while i < 3: { sayln(i) i += 1 } for n in 0...3: { sayln(n) } range(1, 3).each(|x: Integer| sayln(x)) Functions \u00b6 In Loli functions are first-class entities. They can be passed around as arguments, returned, stored in vars, and so on. Declaration \u00b6 fn add(a: Integer, b: Integer): Integer { return a + b } The above defines add as taking two Integer values and producing an Integer as output. In the event that a function has no arguments, or produces no output, that entire section can be omitted: fn life_meaning: Integer { return 42 } fn nothing(a: Integer) { } fn empty { } Like many curly-brace family languages, functions are invoked by passing their arguments like so: add(5, 10) to receive 15 . Omitting a return type doesn't mean that a function doesn't return anything. A function that doesn't mention a return value will actually the value unit of the class Unit . Since all functions actually return a value (even if it's just unit ), it's possible to chain functions that otherwise could not be chained: fn nop { } sayln(nop()) # unit Functions can also be used as arguments: fn square(a: Integer): Integer { return a * a } fn apply(a: Integer, fn: Function(Integer => Integer)): Integer { return fn(a) } sayln(apply(10, square)) # 100 The fn keyword has a number of modifiers that are available to it ( pub , future , sta , etc.). For simplicity, required that modifiers are introduced in alphabetical order. Lambdas \u00b6 One problem with the above example is that square is relatively simple. One is likely to assume that square will take an a , multiply it by itself, and return it. But suppose that the codebase is large, and square is somewhere else. If there is an issue, the source to square must be tracked down. An alternative is to use a lambda. Lambdas are nameless functions that can be used where a function is needed. A lambda begins with (| , followed by argument names, until | is seen. From there, everything until there is a matching ) for the (| is the body of the lambda. Here's the above example, rewritten to use a lambda: fn apply(a: Integer, fn: Function(Integer => Integer)): Integer { return fn(a) } sayln(apply(10, (|a| a * a))) # 100 Another feature of lambdas is that they are values, and the var they're assigned to can opt to have a different lambda. On the other hand, lambdas are quite restricted, and not eligible for many of the function features listed below. Lambdas don't require type information. In the above example, the lambda uses inference to determine that a should be of type Integer . Since lambdas exist primarily to return some kind of a value, the return type of a lambda is the last expression that run. If the last expression is part of a block such as if or match , then the return type is instead unit . Using the future keyword before fn denotes that the function will be declared at some point in the future. Instead of giving the fn a body, it must instead have the triple dot ( ... ) token: future fn add(Integer, Integer): Integer { ... } # *a lot of code* fn add(x: Integer, y: Integer): Integer { return x + y } Functions declared with future are not allowed to specify names for their variables, and are not allowed to use keyword arguments. While there are unresolved future declarations, it is a syntax error to attempt to import a file, declare a class property, or declare a variable. This is done to prevent the resolving function from using variables that are not properly initialized. Additionally, if a class or module finishes with incomplete future declarations, a syntax error is generated immediately. Varargs \u00b6 Adding ... to the end of a type denotes that the function can receive a variable number of arguments of that type. The function receives the arguments as a List of the type provided. If no arguments were passed, the List will be empty. fn sum(n: Integer...): Integer { var result = 0 n.each(|x| result += x) return result } Optargs \u00b6 Adding * before a type, then = <value> after it denotes that the parameter is optional. Optional arguments may be a simple value, or an expression. Required arguments must not come after an optional argument. The expressions of optional arguments, if run, are always run from left to right. As a result, it's permissible for a parameter to depend on another to the left of it. fn sample(a: *Integer = 10): Integer { return a + 10 } The calling function runs the optional argument expressions each time they are needed. As a result, each invocation will receive fresh versions of a default argument that do not carry over into the next invocation. Mixing variable and optional arguments is permissible. By default, the vararg parameter receives an empty List if no values are passed. Mixing these two features allows a different default value. Keyargs \u00b6 Placing :<name> before the name of a parameter will allow the function to be called using keyword arguments. Keyword arguments allow calling a function with arguments in a different order than the function's parameters. The function can then be called either with positional arguments or keyword arguments. fn sample(:first x: Integer, :second y: Integer, :third z: Integer): Integer { return x + y + z } sample(1, 2, 3) # 6 sample(1, :second 2, :third 3) # 6 sample(:third 30, :first 10, :second 5) # 45 Classes \u00b6 User-declared classes provide a way to group together a set of data and related functions. In Loli , classes are only allowed to have one parent class at most as a way of keeping their internal implementation simpler. Declaration \u00b6 class Point(x: Integer, y: Integer) { pub var @x = x pub var @y = y } The body of the class block serves to both define class variables and to initialize them. Inside a class, properties have a @ prefix. Outside of it, both methods and properties are accessed using a dot. class Point(x: Integer, y: Integer) { pub var @x = x pub var @y = y pub fn inc(x_value: Integer, y_value: Integer) { @x += x_value @y += y_value } } Because both class properties and class methods are accessed the same outside of a class, it is a syntax error to have a property and a method with the same name. In situations where class inputs become properties, a shorthand is available: class Point(pub var @x: Integer, pub var @y: Integer) { } Scope \u00b6 Prior to declaring a class member, a scope is needed. There are three possible scopes that a class member or function can have: - pub denotes that the member is available anywhere. - pro restricts the member to the class itself, or any class that inherits from it. - pri restricts the member to only the class. Inheritance \u00b6 Classes use the < token to denote inheriting from another class when writing the header: class Point2D(pub var @x: Integer, pub var @y: Integer) {} class Point3D(x: Integer, y: Integer, pub var @z: Integer) < Point2D(x, y) {} Static methods \u00b6 By default, class methods receive an implicit self parameter as their first argument. The sta qualifier, when applied to a class method, turns that behavior off: Exceptions \u00b6 Occasionally there are errors that are not expected: A subscript of a List is out-of-bounds or there is an accidental attempt to divide by zero. There are predefined exceptions for that. The base of all exceptions is the Exception class. It is declared as follows: class Exception(pub var @message: String) { pub var @traceback: List[String] = [] } When an exception is raised the traceback field of it is replaced with the current call stack. List of predefined exceptions: - Exception : Base class of all raiseable exceptions. - DivisionByZero : Attempt to divide or modulo by zero. - IndexError : Out-of-bounds access of a container (such as List ), String or ByteString . - IOError : Incorrect usage of a File . - KeyError : Attempt to read a value from a Hash that does not exist. - RuntimeError : Bad runtime action such as modifying a hash during iteration or exceeding the recursion limit. - ValueError : Invalid or unreasonable value provided. Any of these exceptions can be inherited to create a custom exception. Exception can be raised using raise keyword: raise IndexError(\"Index out of range\") And catched using try/except block: try: { raise IndexError(\"Index out of range\") except Exception as e: sayln(\"Exception: {0}\".format(e.message)) } Generics \u00b6 In Loli classes, enums, and functions can make use of generics. They must be a single capital letter, must be declared before use, and yet there are no traits or qualifiers. class Stack[A](element: A) { pub var @contents = [element] pub fn push(value: A): self { @contents.push(value) } } Stack(1).push(2).push(3) # [1, 2, 3] Import \u00b6 Import system is very similar to Python. import sys sys.exit() import package import package as pkg import (somefn, somevar) package import \"folder/package\" Import paths \u00b6 For default paths tried in the following order: ./<name>.li ./<name>.(dll/so) ./pkg/<name>/<name>.li ./pkg/<name>/<name>.(dll/so) <original root>/pkg/<name>/<name>.li <original root>/pkg/<name>/<name>.(dll/so) If a module executes code, the code is run only the first time the module is loaded. Enums \u00b6 Enums are a datatype composed of a fixed set of variant classes. A variant class can take any number of types (including the enum itself), or can be empty. Enums declarations can include methods as well as variants. enum Rgb { Red, Green, Blue fn is_blue: Boolean { match self: { case Blue: return true else: return false } } } Since enums aren't inheritable, their methods don't need qualifiers like with user-defined classes. By default, variants of an enum are flat. Variants of a flat enum can be referenced directly. In contrast, the scoped qualifier makes it so that variants of an enum are only accessible through the enum name. Also variants support varargs and keyargs, but no optargs because they are not actually functions.","title":"Home"},{"location":"#welcome","text":"Loli is a embedded programming language. Loli is statically-typed, Loli uses reference counting for memory management with garbage collection as a fallback. Key features of Loli : - Built-in template mode - Embed/extend in C - Single-inheritance classes - Exceptions - Generics - Algebraic data types - Built-in coroutines","title":"Welcome"},{"location":"#syntax-overview","text":"","title":"Syntax overview"},{"location":"#declarations","text":"Variables must be declared before they are used, with the var keyword: var x = 5 var y: Double = 5.32 var z = [1, 2, 3], hi = \"Hello, world!\" The value used to initialize a variable determines the type of the variable. In most cases, var does not need extra type information. However, sometimes the right side of an initialization doesn't provide enough info and type information must be provided: var some_list: List[Double] = []","title":"Declarations"},{"location":"#literals","text":"Loli has several predefined classes, and syntax for using them as well.","title":"Literals"},{"location":"#boolean","text":"Either true or false .","title":"Boolean"},{"location":"#byte","text":"A numeric value from 0 to 255. Can be declared like an Integer but with a suffix of t , or like a String using a single character or escape sequence between single quote marks: 0t 0xFFt 255t 'a' '\\t'","title":"Byte"},{"location":"#bytestring","text":"An array of Byte values. A String , but with no guarantees about embedded \\0 values or utf-8. Allows any escape character between quotes: b\"123456\" b\"\\0\\1\\2\" b\"\\255\\254\\t\" b\"\"\"A \\ multi-line \\ ByteString\"\"\"","title":"ByteString"},{"location":"#double","text":"0.00000005 -1.7 10e1 5e-5","title":"Double"},{"location":"#hash","text":"A Hash is a key to value mapping. Only Integer and String can be used for the key. The value can be anything, so long as there is a consistent type. If a Hash literal contains the same key twice, both values will still be computed if necessary, but the right-most key wins: var a_hash = [\"a\" => 1, \"b\" => 2, \"c\" => 3] var empty_hash: Hash[String, Integer] = []","title":"Hash"},{"location":"#integer","text":"A 64-bit signed value that can be represented using different bases: 12345 -67890 0c744 x0xFF 0b101010101","title":"Integer"},{"location":"#list","text":"A List is composed of values put together in brackets. The values must have some common type: var a_list = [1, 2, 3] var a_range = range(1, 3) var empty_list: List[Double] = []","title":"List"},{"location":"#string","text":"Represents a block of text. String carries the guarantee that all instances are valid utf-8, and that they do not carry \\0 characters inside. String literals are single-line by default, but can be multi-line as well: var hi = \"Hello, world!\" var multi_line = \"\"\"Hello, \\ world!\"\"\"","title":"String"},{"location":"#tuple","text":"A Tuple is similar to a List , except that Tuple s have a fixed size, but can hold types that don't have any similarity to each other. A Tuple begins with <[ and ends with ]> : var a_tuple: Tuple[String, Double] = <[\"hi\", 34.93]>","title":"Tuple"},{"location":"#comments","text":"There are two kinds of comments: # A single-line comment #[ And a multi-line comment ]#","title":"Comments"},{"location":"#escape-codes","text":"String , ByteString , and Byte support the following escape sequences: - \\a : Bell - \\b : Backspace - \\t : Tab - \\n : A newline - \\r : Carriage return - \\\" : The \" character - \\' : The ' character - \\\\ : The \\ character - \\/ : \\ on Windows, / elsewhere. - \\ddd : 'ddd' is up to 3 digits, scanned in decimal. This can yield any value between 0 and 255 inclusive. Scanning stops either after 3 digits have been consumed, or a non-base 10 digit occurs. - \\<newline> : ByteString and String only. The newline of the current line and the leading whitespace ( ' ' or '\\t' ) will be omitted from the literal.","title":"Escape codes"},{"location":"#operators","text":"Basic arithmatic operations ( + - * / ) can be used for two Double values, or two Integer values, or when there is one Double and one Integer value. The result is a Double if either side is a Double , Integer otherwise. Other primitive operations (shifts, bitwise operations, and modulo) are only valid if both sides are Integer .","title":"Operators"},{"location":"#comparison","text":"Comparison operations ( >= > < <= ) are allowed on any two sets of Integer , String , or Double . Equality operations ( == != ) are allowed on any two equivalent types. Simple values like Integer , and Double are straightforward: They are equal only when they are the same value. List , Tuple , Hash , and variants use structural comparison. All other containers and more interesting types use identity comparison. A comparison such as SomeClass(2, 4) == SomeClass(2, 4) will always return false , since each SomeClass is a different instance.","title":"Comparison"},{"location":"#interpolation","text":"The ++ operator and String.format all make use of built-in interpolation. Interpolation works as follows: Primitive values such as Integer , Double , and String have their content written out. Built-in containers have their inner contents written out. Hash does not guarantee an ordering to the contents it writes out. Non-scoped variants print just their name and their contents. Scoped variants print out the enum name and a dot first. Classes print out their address.","title":"Interpolation"},{"location":"#if","text":"if x == 0: { # do something... elif x == 1: # do something another... else: # do something another... }","title":"If"},{"location":"#loops","text":"There are while , for and built-in classes' iterators(such as List.each ): var i = 0 while i < 3: { sayln(i) i += 1 } for n in 0...3: { sayln(n) } range(1, 3).each(|x: Integer| sayln(x))","title":"Loops"},{"location":"#functions","text":"In Loli functions are first-class entities. They can be passed around as arguments, returned, stored in vars, and so on.","title":"Functions"},{"location":"#declaration","text":"fn add(a: Integer, b: Integer): Integer { return a + b } The above defines add as taking two Integer values and producing an Integer as output. In the event that a function has no arguments, or produces no output, that entire section can be omitted: fn life_meaning: Integer { return 42 } fn nothing(a: Integer) { } fn empty { } Like many curly-brace family languages, functions are invoked by passing their arguments like so: add(5, 10) to receive 15 . Omitting a return type doesn't mean that a function doesn't return anything. A function that doesn't mention a return value will actually the value unit of the class Unit . Since all functions actually return a value (even if it's just unit ), it's possible to chain functions that otherwise could not be chained: fn nop { } sayln(nop()) # unit Functions can also be used as arguments: fn square(a: Integer): Integer { return a * a } fn apply(a: Integer, fn: Function(Integer => Integer)): Integer { return fn(a) } sayln(apply(10, square)) # 100 The fn keyword has a number of modifiers that are available to it ( pub , future , sta , etc.). For simplicity, required that modifiers are introduced in alphabetical order.","title":"Declaration"},{"location":"#lambdas","text":"One problem with the above example is that square is relatively simple. One is likely to assume that square will take an a , multiply it by itself, and return it. But suppose that the codebase is large, and square is somewhere else. If there is an issue, the source to square must be tracked down. An alternative is to use a lambda. Lambdas are nameless functions that can be used where a function is needed. A lambda begins with (| , followed by argument names, until | is seen. From there, everything until there is a matching ) for the (| is the body of the lambda. Here's the above example, rewritten to use a lambda: fn apply(a: Integer, fn: Function(Integer => Integer)): Integer { return fn(a) } sayln(apply(10, (|a| a * a))) # 100 Another feature of lambdas is that they are values, and the var they're assigned to can opt to have a different lambda. On the other hand, lambdas are quite restricted, and not eligible for many of the function features listed below. Lambdas don't require type information. In the above example, the lambda uses inference to determine that a should be of type Integer . Since lambdas exist primarily to return some kind of a value, the return type of a lambda is the last expression that run. If the last expression is part of a block such as if or match , then the return type is instead unit . Using the future keyword before fn denotes that the function will be declared at some point in the future. Instead of giving the fn a body, it must instead have the triple dot ( ... ) token: future fn add(Integer, Integer): Integer { ... } # *a lot of code* fn add(x: Integer, y: Integer): Integer { return x + y } Functions declared with future are not allowed to specify names for their variables, and are not allowed to use keyword arguments. While there are unresolved future declarations, it is a syntax error to attempt to import a file, declare a class property, or declare a variable. This is done to prevent the resolving function from using variables that are not properly initialized. Additionally, if a class or module finishes with incomplete future declarations, a syntax error is generated immediately.","title":"Lambdas"},{"location":"#varargs","text":"Adding ... to the end of a type denotes that the function can receive a variable number of arguments of that type. The function receives the arguments as a List of the type provided. If no arguments were passed, the List will be empty. fn sum(n: Integer...): Integer { var result = 0 n.each(|x| result += x) return result }","title":"Varargs"},{"location":"#optargs","text":"Adding * before a type, then = <value> after it denotes that the parameter is optional. Optional arguments may be a simple value, or an expression. Required arguments must not come after an optional argument. The expressions of optional arguments, if run, are always run from left to right. As a result, it's permissible for a parameter to depend on another to the left of it. fn sample(a: *Integer = 10): Integer { return a + 10 } The calling function runs the optional argument expressions each time they are needed. As a result, each invocation will receive fresh versions of a default argument that do not carry over into the next invocation. Mixing variable and optional arguments is permissible. By default, the vararg parameter receives an empty List if no values are passed. Mixing these two features allows a different default value.","title":"Optargs"},{"location":"#keyargs","text":"Placing :<name> before the name of a parameter will allow the function to be called using keyword arguments. Keyword arguments allow calling a function with arguments in a different order than the function's parameters. The function can then be called either with positional arguments or keyword arguments. fn sample(:first x: Integer, :second y: Integer, :third z: Integer): Integer { return x + y + z } sample(1, 2, 3) # 6 sample(1, :second 2, :third 3) # 6 sample(:third 30, :first 10, :second 5) # 45","title":"Keyargs"},{"location":"#classes","text":"User-declared classes provide a way to group together a set of data and related functions. In Loli , classes are only allowed to have one parent class at most as a way of keeping their internal implementation simpler.","title":"Classes"},{"location":"#declaration_1","text":"class Point(x: Integer, y: Integer) { pub var @x = x pub var @y = y } The body of the class block serves to both define class variables and to initialize them. Inside a class, properties have a @ prefix. Outside of it, both methods and properties are accessed using a dot. class Point(x: Integer, y: Integer) { pub var @x = x pub var @y = y pub fn inc(x_value: Integer, y_value: Integer) { @x += x_value @y += y_value } } Because both class properties and class methods are accessed the same outside of a class, it is a syntax error to have a property and a method with the same name. In situations where class inputs become properties, a shorthand is available: class Point(pub var @x: Integer, pub var @y: Integer) { }","title":"Declaration"},{"location":"#scope","text":"Prior to declaring a class member, a scope is needed. There are three possible scopes that a class member or function can have: - pub denotes that the member is available anywhere. - pro restricts the member to the class itself, or any class that inherits from it. - pri restricts the member to only the class.","title":"Scope"},{"location":"#inheritance","text":"Classes use the < token to denote inheriting from another class when writing the header: class Point2D(pub var @x: Integer, pub var @y: Integer) {} class Point3D(x: Integer, y: Integer, pub var @z: Integer) < Point2D(x, y) {}","title":"Inheritance"},{"location":"#static-methods","text":"By default, class methods receive an implicit self parameter as their first argument. The sta qualifier, when applied to a class method, turns that behavior off:","title":"Static methods"},{"location":"#exceptions","text":"Occasionally there are errors that are not expected: A subscript of a List is out-of-bounds or there is an accidental attempt to divide by zero. There are predefined exceptions for that. The base of all exceptions is the Exception class. It is declared as follows: class Exception(pub var @message: String) { pub var @traceback: List[String] = [] } When an exception is raised the traceback field of it is replaced with the current call stack. List of predefined exceptions: - Exception : Base class of all raiseable exceptions. - DivisionByZero : Attempt to divide or modulo by zero. - IndexError : Out-of-bounds access of a container (such as List ), String or ByteString . - IOError : Incorrect usage of a File . - KeyError : Attempt to read a value from a Hash that does not exist. - RuntimeError : Bad runtime action such as modifying a hash during iteration or exceeding the recursion limit. - ValueError : Invalid or unreasonable value provided. Any of these exceptions can be inherited to create a custom exception. Exception can be raised using raise keyword: raise IndexError(\"Index out of range\") And catched using try/except block: try: { raise IndexError(\"Index out of range\") except Exception as e: sayln(\"Exception: {0}\".format(e.message)) }","title":"Exceptions"},{"location":"#generics","text":"In Loli classes, enums, and functions can make use of generics. They must be a single capital letter, must be declared before use, and yet there are no traits or qualifiers. class Stack[A](element: A) { pub var @contents = [element] pub fn push(value: A): self { @contents.push(value) } } Stack(1).push(2).push(3) # [1, 2, 3]","title":"Generics"},{"location":"#import","text":"Import system is very similar to Python. import sys sys.exit() import package import package as pkg import (somefn, somevar) package import \"folder/package\"","title":"Import"},{"location":"#import-paths","text":"For default paths tried in the following order: ./<name>.li ./<name>.(dll/so) ./pkg/<name>/<name>.li ./pkg/<name>/<name>.(dll/so) <original root>/pkg/<name>/<name>.li <original root>/pkg/<name>/<name>.(dll/so) If a module executes code, the code is run only the first time the module is loaded.","title":"Import paths"},{"location":"#enums","text":"Enums are a datatype composed of a fixed set of variant classes. A variant class can take any number of types (including the enum itself), or can be empty. Enums declarations can include methods as well as variants. enum Rgb { Red, Green, Blue fn is_blue: Boolean { match self: { case Blue: return true else: return false } } } Since enums aren't inheritable, their methods don't need qualifiers like with user-defined classes. By default, variants of an enum are flat. Variants of a flat enum can be referenced directly. In contrast, the scoped qualifier makes it so that variants of an enum are only accessible through the enum name. Also variants support varargs and keyargs, but no optargs because they are not actually functions.","title":"Enums"},{"location":"builtins/","text":"Built-in modules reference \u00b6 Except for the builtin module, all modules listed here can be imported from any file inside of the interpreter. This is unlike other modules, which are loaded using relative paths. These modules can be imported like import sys , then used like sys.exit() . The builtin module is unique because the classes, enums, and functions are the foundation of the interpreter. Instead of requiring it to be imported, the contents of builtin are instead available without a namespace. builtin \u00b6 The builtin package provides the classes, vars, and functions that form the foundation of Loli . Class Boolean \u00b6 The Boolean class represents a value that is either true or false . fn to_i: Integer \u00b6 Convert a Boolean to an Integer . true becomes 1 , false becomes 0 . fn to_s: String \u00b6 Convert a Boolean to a String . Class Byte \u00b6 The Byte class represents a wrapper over a single Byte value. A Byte value is always unsigned, giving it a range from 0 to 255. Byte literals are written using 't' as the suffix on an Integer value. fn to_i: Integer \u00b6 Convert a Byte to an Integer . Class ByteString \u00b6 The ByteString class represents a bag of bytes. A ByteString may have \\0 values embedded within it. It may also have data that is not valid as utf-8. The ByteString class currently does not support any primitive operations. fn each_byte(fun: Function(Byte)) \u00b6 Call fun for each Byte within the given ByteString . fn to_s: String \u00b6 Attempt to transform the given ByteString into a String , invalid utf-8 or embedded \\0 values within self will raise a ValueError . fn len: Integer \u00b6 Return the number of Byte values within self . fn slice(start: Integer = 0, stop: Integer = -1): ByteString \u00b6 Create a new ByteString copying a section of self from start to stop. If a negative index is given, it is treated as an offset from the end of self , with -1 being considered the last element. Class Coroutine \u00b6 A Coroutine is similar to a Function , except that it can also yield values at different points along its lifetime. Every Coroutine has a callstack that belongs to it, as well as an exception state. A Coroutine 's status can be discovered by one of the is_ methods. The Coroutine type takes two types. The first is the type that the Coroutine will be returning or yielding. The second is the type that the Coroutine takes as a message. A Coroutine can take empty Unit messages for simplicity, or a more interesting type if a more bidirectional kind of messaging is wanted. A Coroutine can get the value resumed using Coroutine.receive while within the Coroutine . The first argument of a Function to be made a Coroutine is always the Coroutine itself. If the Function specifies extra arguments, those arguments are to be passed to the intermediate result of Coroutine.create . sta fn build(fun: Function(Coroutine[A, B])): Coroutine[A, B] \u00b6 Build a new Coroutine that wraps over the Function provided. sta fn build_with_value(fun: Function(Coroutine[A, B], C), value: C): Coroutine[A, B] \u00b6 Build a new Coroutine that wraps over the Function provided. The base Function has the second argument set to 'value' exactly once before any resumption takes place. This method is provided so that a Coroutine can take an extra value (perhaps a Tuple ) without needing to be a closure. fn is_done: Boolean \u00b6 Returns true if the Coroutine has returned a value instead of yielding, false otherwise. fn is_failed: Boolean \u00b6 Returns true if the Coroutine raised an exception, false otherwise. fn is_waiting: Boolean \u00b6 Returns true if the Coroutine is ready to be resumed, false otherwise. fn is_running: Boolean \u00b6 Returns true if the Coroutine is running, false otherwise. Note that this does not mean that the Coroutine is the one currently running, only that it is running. fn receive: B \u00b6 This function returns the value that the Coroutine is holding, so long as the Coroutine is the one currently running. The value stored by the Coroutine is initially the first argument sent to the intermediate builder. Following that, it is the last value that was sent to the Coroutine using Coroutine.resume_with . sta fn resume(self: Coroutine[A, Unit]): Option[A] \u00b6 Attempt to resume the Coroutine provided. A Coroutine can be resumed only if it is currently in the 'waiting' state. This function does not send a value to the Coroutine which is why it requires the second parameter to be Unit . If the Coroutine is suspended and yields a value, the result is a Some of that value. Otherwise, this returns None . Note that if a Coroutine returns a value instead of yielding, the value is ignored and the result is None . fn resume_with(value: B): Option[A] \u00b6 Attempt to resume the Coroutine provided. A Coroutine can be resumed only if it is currently in the 'waiting' state. This function includes a value for the Coroutine to store. The value is stored only if the Coroutine is resumed. If stored, the old value is ejected from the Coroutine provided. If the Coroutine is suspended and yields (or returns) a value, the result is a Some of that value. Otherwise, this returns None . yield(value: A) \u00b6 Yield value from the Coroutine given. Control returns to whatever invoked self . Raises RuntimeError if self is the current Coroutine , or within a foreign call. Class Double \u00b6 fn to_i: Integer \u00b6 Convert a Double to an Integer . Class File \u00b6 The File class provides a wrapper over a C FILE * struct. A File is closed automatically when a scope exits (though not immediately). However, it is also possible to manually close a File . fn close \u00b6 Close self if it is open, or do nothing if already closed. Note that for standard streams, this marks the File as closed, but does not actually close the stream. fn each_line(fun: Function(ByteString)) \u00b6 Read each line of text from self , passing it down to fun for processing. Raises IOError if self is not open for reading, or is closed. fn flush \u00b6 This function writes all buffered data associated with the File provided. Raises IOError if self is closed or not open for writing. sta fn open(path: String, mode: String): File \u00b6 Attempt to open path using the mode given. mode may be one of the following: - r : read only, must exist - w : write only - a : append, create if not exist - r+ : read+write, must exist - w+ : read+write, creates an empty file if needed. - a+ : read+append Raises IOError if unable to open path , or an invalid mode is provided. fn print(data: A) \u00b6 Attempt to write the contents of data to the file provided. data is written with a newline at the end. Raises IOError if self is closed or is not open for writing. fn read(size: *Integer = -1): ByteString \u00b6 Read size bytes from self . If size is negative, then the full contents of self are read. This stops if either size bytes are read, or the end of self is reached. Raises IOError if self is not open for reading, or is closed. fn read_line: ByteString \u00b6 Attempt to read a line of text from self . When end of file reached, returns b\"\" . Raises IOError if self is not open for reading, or is closed. fn write(data: A) \u00b6 Attempt to write the contents of data to the file provided. Raises IOError if self is closed or is not open for writing. Class Function \u00b6 The Function class represents a block of code to be called, which may or may not produce a value. Function values are first-class, and can be passed around as arguments, placed into a List , and so on. Class Hash \u00b6 The Hash class provides a mapping between a key and a value. Hash values can be created through [key1 => value1, key2 => value2, ...] . When writing a Hash , the key is the first type, and the value is the second. [1 => \"a\", 2 => \"b\", 3 => \"c\"] would therefore be written as Hash[Integer, String] . fn clear \u00b6 Removes all pairs currently present within self . Raises RuntimeError if self is currently being iterated over. fn delete(key: A) \u00b6 Attempt to remove key from self . If key is not present within self raises KeyError . Raises RuntimeError if self is currently being iterated over. fn each_pair(fun: Function(A, B)) \u00b6 Iterate through each pair that is present within self . For each of the pairs, call fun with the key and value of each pair. fn get(key: A): Option[B] \u00b6 Attempt to find key within self . If key is present, then a Some containing the associated value is returned. Otherwise, this returns None . fn has_key(key: A): Boolean \u00b6 Return true if key is present within self , false otherwise. fn keys: List[A] \u00b6 Construct a List containing all values that are present within self . There is no guarantee of the ordering of the resulting List . fn map_values(fun: Function(B => C)): Hash[A, C] \u00b6 This iterates through self and calls fun for each element present. The result of this function is a newly-made Hash where each value is the result of the call to fun . fn merge(others: Hash[A, B]...): Hash[A, B] \u00b6 Create a new Hash that holds the result of self and each Hash present within others. When duplicate elements are found, the value of the right-most Hash wins. fn reject(fun: Function(A, B => Boolean)): Hash[A, B] \u00b6 This calls fun for each element present within self . The result of this function is a newly-made Hash containing all values for which fun returns false . fn select(fun: Function(A, B => Boolean)): Hash[A, B] \u00b6 This calls fun for each element present within self . The result of this function is a newly-made Hash containing all values for which fun returns true . fn len: Integer \u00b6 Returns the number of key-value pairs present within self . Class Integer \u00b6 The Integer class is s native numeric type, represented with C int64_t . fn to_bool: Boolean \u00b6 Converts an Integer to a Boolean . fn to_b: Byte \u00b6 Convert an Integer to a Byte , truncating the value if necessary. fn to_d: Double \u00b6 Converts an Integer to a Double . fn to_s: String \u00b6 Convert an Integer to a String using base-10. Class List \u00b6 The List class represents a container of a given type, written as List[<inner type>] . A List value can be accessed through a positive index or a negative one (with negative indexes being an offset from the end). Attempting to access an invalid index will raise IndexError . fn append(list: List[A]): List[A] \u00b6 Append list to end of self . Returns modified list. fn clear \u00b6 Removes all elements present within self . No error is raised if self is being iterated over. fn count(fun: Function(A => Boolean)): Integer \u00b6 This calls fun for each element within self . The result of this function is the number of times that fun returns true . fn delete_at(index: Integer) \u00b6 Attempts to remove index from the List . If index is negative, then it is considered an offset from the end of the List . Raises IndexError if index is out of range. fn each(fun: Function(A)): List[A] \u00b6 Calls fun for each element within self . The result of this function is self , so that this method can be chained with others. fn each_index(fun: Function(Integer)): List[A] \u00b6 Calls fun for each element within self . Rather than receive the elements of self , fun instead receives the index of each element. fn fold(start: A, fun: Function(A, A => A)): A \u00b6 This calls fun for each element present within self . The first value sent to fun is initially start, but will later be the result of fun . Therefore, the value as it accumulates can be found in the first value sent to fun . The result of this function is the result of doing an accumulation on each element within self . sta fn fill(count: Integer, fun: Function(Integer => A)): List[A] \u00b6 Generate a List of count items using fun . This calls fun with an index that starts at 0 and proceeds until count , and does not include count . If count is 0 or negative, then the resulting List will be empty. fn get(index: Integer): Option[A] \u00b6 Attempt to find index within self . If the index is within self , then the value is returned within a Some . Otherwise, this returns None . fn insert(index: Integer, value: A) \u00b6 Attempt to insert value at index within self . If index is negative, then it is treated as an offset from the end of self . Raises IndexError if index is not within self . fn join(separator: *String = \"\"): String \u00b6 Create a String consisting of the elements of self joined with separator . The elements of self are converted to a String as if they were interpolated. If self is empty, then the result is an empty String . fn map(fun: Function(A => B)): List[B] \u00b6 This calls fun on each element within self . The result of this function is a newly-made List containing the results of fun . fn pop: A \u00b6 Attempt to remove and return the last element within self . Raises IndexError if self is empty. fn push(value: A): List[A] \u00b6 Add value to the end of self . fn reject(fun: Function(A => Boolean)): List[A] \u00b6 This calls fun for each element within self . The result is a newly-made List holding each element where fun returns false . sta fn repeat(count: Integer, value: A): List[A] \u00b6 This creates a new List that contains value repeated count times. Raises ValueError if count is less than 1. fn select(fun: Function(A => Boolean)): List[A] \u00b6 This calls fun for each element within self . The result is a newly-made List holding each element where fun returns true . fn len: Integer \u00b6 Returns the number of elements that are within self . fn shift: A \u00b6 This attempts to remove the last element from self and return it. Raises ValueError if self is empty. fn slice(start: Integer = 0, stop: Integer = -1): List[A] \u00b6 Create a new List copying a section of self from start to stop . If a negative index is given, it is treated as an offset from the end of self , with -1 being considered the last element. Raises IndexError if start or stop is out of range or the start is larger than the stop . fn unshift(value: A): List[A] \u00b6 Inserts value at the front of self , moving all other elements to the right. fn zip(others: List[$1]...): List[Tuple[A, $1]] \u00b6 This creates a List that contains a merger of the values within each of the elements in others and self . The $1 type is a special type that allows this method to work with any number of List values. Class String \u00b6 The String class provides a wrapper over a C char * . The String class is guaranteed to have a single \\0 terminator. Additionally, a String is guaranteed to always be valid utf-8. The methods on the String class treat the underlying String as being immutable, and thus always create a new String instead of modifying the existing one. fn char_at(index: Integer): Byte \u00b6 Returns a characted at index in the self . If index is negative, then it is considered an offset from the end of the self . Raises IndexError if index is not within self . fn format(args: $1...): String \u00b6 This creates a new String by processing self as a format. Format specifiers must be between braces ( {} ), and must be between 0 and 99 . Each format specifier is replaced with the according argument, with the first argument being at 0, the second at 1, and so on. Raises ValueError if a format specifier is malformed or has too many digits. Raises IndexError if the format specifier specifies an out-of-range argument. fn ends_with(end: String): Boolean \u00b6 Checks if self ends with end . fn find(needle: String, start: *Integer = 0): Option[Integer] \u00b6 Check for needle being within self . By default, this begins at the start of self . If start is non-zero, then the search begins start bytes away from the beginning of self . If start lies within the middle of a utf-8 codepoint, then None is returned. If needle is found, the result is a Some holding the index. Otherwise, this returns None . fn is_alnum: Boolean \u00b6 Return true if self has only alphanumeric( [a-zA-Z0-9]+ ) characters, false otherwise. fn is_alpha: Boolean \u00b6 Return true if self has only alphabetical( [a-zA-Z]+ ) characters, false otherwise. fn is_digit: Boolean \u00b6 Return true if self has only digit( [0-9]+ ) characters, false otherwise. fn is_space: Boolean \u00b6 Returns true if self has only space( \" \\t\\r\\n\" ) characters, false otherwise. fn lower: String \u00b6 Checks if any characters within self are within [ A-Z] . If so, it creates a new String with [A-Z] replaced by [a-z] . Otherwise, self is returned. fn lstrip(to_strip: String): String \u00b6 This walks through self from left to right, stopping on the first utf-8 chunk that is not found within to_strip . The result is a newly-made copy of self without the elements within to_strip at the front. fn to_i: Integer \u00b6 Attempts to convert self into an Integer . self is parsed as a base-10 encoded value. If the value is not a valid Integer , ValueError will raised. fn to_d: Double \u00b6 Attempts to convert self into an Double . self is parsed as a base-10 encoded value. If the value is not a valid Double , ValueError will raised. fn replace(needle: String, new: String): String` \u00b6 Create a new String consisting of every needle replaced with new . fn rstrip(to_strip: String): String \u00b6 This walks through self from right to left, stopping on the first utf-8 chunk that is not found within to_strip . The result is a newly-made copy of self without the elements of to_strip at the end. fn len: Integer \u00b6 Return the number of bytes in self . This is equivalent to ByteString.len . fn slice(start: Integer = 0, stop: Integer = -1): String \u00b6 Create a new String copying a section of self from start to stop . This function works using byte indexes into the String value. If a negative index is given, it is treated as an offset from the end of self, with -1 being considered the last element. Raises IndexError if either start or stop is out of range or if the start is larger than the stop . Raises ValueError if the resulting slice would not be valid utf-8. fn split(split_by: *String = \" \"): List[String] \u00b6 This attempts to split self using split_by , with a default value of a single space. Raises ValueError if split_by is empty. fn starts_with(with: String): Boolean \u00b6 Checks if self starts with with . fn strip(to_strip: String): String \u00b6 This walks through self from right to left, and then from left to right. The result of this is a newly-made String without any elements within to_strip at either end. fn to_bs: ByteString \u00b6 Produce a copy of self as a ByteString . fn trim: String \u00b6 Checks if self starts or ends with any of \" \\t\\r\\n\" . If it does, then a new String is made with spaces removed from both sides. If it does not, then this returns self . fn upper: String \u00b6 Checks if any characters within self are within [a-z] . If so, it creates a new String with [a-z] replaced by [A-Z] . Otherwise, self is returned. Class Tuple \u00b6 The Tuple class provides a fixed-size container over a set of types. Tuple is ideal for situations where a variety of data is needed, but a class is too complex. Tuple literals are created by <[value1, value2, ...]> . Member of the Tuple class can be accessed through subscripts. Unlike List , Tuple does not support negative indexes. Enum Option Option[A] { Some(A), None} \u00b6 The Option type presents a way to hold either a value of A , or None , with None being valid for any Option . A common use for this is as a return type for functions that may fail, but have no meaningful error message. fn and(other: Option[B]): Option[B] \u00b6 If self is a Some , this returns other . Otherwise, this returns None . fn and_then(fun: Function(A => Option[B])): Option[B] \u00b6 If self is a Some , this calls fun with the value within the Some . The result is the result of the Option returned by fun . Otherwise, this returns None . fn is_none: Boolean \u00b6 If self is a Some , this returns false . Otherwise, this returns true . fn is_some: Boolean \u00b6 If self is a Some , this returns true . Otherwise, this returns false . fn map(fun: Function(A => B)): Option[B] \u00b6 If self is a Some , this returns a Some holding the result of fun . Otherwise, this returns None . fn or(alternate: Option[A]): Option[A] \u00b6 If self is a Some , this returns self . Otherwise, this returns alternate . fn or_else(fun: Function( => Option[A])): Option[A] \u00b6 If self is a Some , this returns self . Otherwise, this returns the result of calling fun . fn unwrap: A \u00b6 If self is a Some , this returns the value contained within. Raises ValueError if self is None . fn unwrap_or(alternate: A): A \u00b6 If self is a Some , this returns the value with self . Otherwise, this returns alternate . fn unwrap_or_else(fun: Function( => A)): A \u00b6 If self is a Some , this returns the value with self . Otherwise, this returns the result of calling fun . Enum Result Result[A, B] { Failure(A), Success(B)} \u00b6 Result is an enum that holds either a Failure or Success . This enum is for situations where the function that fails has an error message to deliver. fn failure: Option[A] \u00b6 If self contains a Failure , produces a Some(A) . If self contains a Right , produces None . fn is_failure: Boolean \u00b6 Return true if self contains a Failure , false otherwise. fn is_success: Boolean \u00b6 Return true if self contains a Success , false otherwise. fn success: Option[B] \u00b6 If self contains a Failure , produces a None . If self contains a Success , produces Right(B) . Function sayln sayln(value: A) \u00b6 Write value to stdout , plus a newline ( \"\\n\" ). Function say say(value: A) \u00b6 Write value to stdout (without a newline). Function input input(prompt: *String): ByteString \u00b6 Write value to stdout , then read input from stdin . Function range range(start: *Integer = 0, end: Integer) \u00b6 Build list contains all numbers from start to end (inclusive). Function calltrace calltrace: List[String] \u00b6 Returns a List with one String for each function that is currently entered. Variable stdin stdin: File \u00b6 Provides a wrapper around the stdin . Variable stderr stderr: File \u00b6 Provides a wrapper around the stderr . Variable stdout stdout: File \u00b6 Provides a wrapper around the stdout . random \u00b6 The random package provides access to a pseudo-random number generation. Class Random \u00b6 The Random class provides access to the random number generator. Each instance is completely separate from all others. The constructor for this class takes a seed. If the seed provided is 0 or less, then the current time is used instead. fn (seed: *Integer = 0): Random \u00b6 fn between(lower: Integer, upper: Integer): Integer \u00b6 Generate a random Integer value between lower and upper . Raises ValueError is raised if the range is empty, or reversed. sys \u00b6 fn listdir(path: String): List[String] \u00b6 Returns list of files in path . Raises IOError if path is not exists or accessible. fn rmdir(path: String): Boolean \u00b6 Removes a directory whose name is given by path . The directory shall be removed only if it is an empty directory. Raises IOError if path is not exists or accessible, otherwise returns true . fn remove(path: String): Boolean \u00b6 Removes a file whose name is given by path . Raises IOError if path is not exists or accessible, otherwise returns true . fn mkdir(path: String): Boolean \u00b6 Creates a file whose name is given by path . Raises IOError if path is not a valid path name, otherwise returns true . fn exists(path: String): Boolean \u00b6 Returns true , if path is a existing file or directory, false otherwise. fn is_dir(path: String): Boolean \u00b6 Returns true , if path is a existing directory, false otherwise. fn is_file(path: String): Boolean \u00b6 Returns true , if path is a existing file, false otherwise. fn exit(exit_code: *Integer) \u00b6 Stop execution of the program and return code exit_code . fn getenv(name: String): Option[String] \u00b6 Search the environment for name , returning either a Some with the contents, or None . fn setenv(name: String, value: String): Boolean \u00b6 Set environment variable name to value , on success return true , false otherwise. fn recursion_limit: Integer \u00b6 Return the current recursion limit. fn set_recursion_limit(limit: Integer) \u00b6 Attempt to set limit as the maximum recursion limit. Raises ValueError if limit is lower than the current recursion depth or an negative value. Variable argv argv: List[String] \u00b6 This contains arguments sent to the program through the command-line. If interpreter was not invoked from the command-line then this is empty. time \u00b6 The time package provides access to basic time information on the system. Class Time \u00b6 Instances of this class represent a single point in time. This class also includes static methods to provide a few extra features. sta fn clock: Double \u00b6 Returns the number of seconds of CPU time the interpreter has used. sta fn now: Time \u00b6 Returns a Time instance representing the current system time. fn to_s(format: *String = \"%Y-%m-%d %H:%M:%S %z\"): String \u00b6 Return a String representation of a Time instance in format format. fn since_epoch: Integer \u00b6 Returns the value of self as a number of seconds since the epoch. hash \u00b6 The hash provides access to hash-functions, e.g. md5 . fn md5(input: String): String \u00b6 Returns a md5 hash from input . fn sha1(input: String): String \u00b6 Returns a sha1 hash from input .","title":"Built-ins"},{"location":"builtins/#built-in-modules-reference","text":"Except for the builtin module, all modules listed here can be imported from any file inside of the interpreter. This is unlike other modules, which are loaded using relative paths. These modules can be imported like import sys , then used like sys.exit() . The builtin module is unique because the classes, enums, and functions are the foundation of the interpreter. Instead of requiring it to be imported, the contents of builtin are instead available without a namespace.","title":"Built-in modules reference"},{"location":"builtins/#builtin","text":"The builtin package provides the classes, vars, and functions that form the foundation of Loli .","title":"builtin"},{"location":"builtins/#class-boolean","text":"The Boolean class represents a value that is either true or false .","title":"Class Boolean"},{"location":"builtins/#fn-to_i-integer","text":"Convert a Boolean to an Integer . true becomes 1 , false becomes 0 .","title":"fn to_i: Integer"},{"location":"builtins/#fn-to_s-string","text":"Convert a Boolean to a String .","title":"fn to_s: String"},{"location":"builtins/#class-byte","text":"The Byte class represents a wrapper over a single Byte value. A Byte value is always unsigned, giving it a range from 0 to 255. Byte literals are written using 't' as the suffix on an Integer value.","title":"Class Byte"},{"location":"builtins/#fn-to_i-integer_1","text":"Convert a Byte to an Integer .","title":"fn to_i: Integer"},{"location":"builtins/#class-bytestring","text":"The ByteString class represents a bag of bytes. A ByteString may have \\0 values embedded within it. It may also have data that is not valid as utf-8. The ByteString class currently does not support any primitive operations.","title":"Class ByteString"},{"location":"builtins/#fn-each_bytefun-functionbyte","text":"Call fun for each Byte within the given ByteString .","title":"fn each_byte(fun: Function(Byte))"},{"location":"builtins/#fn-to_s-string_1","text":"Attempt to transform the given ByteString into a String , invalid utf-8 or embedded \\0 values within self will raise a ValueError .","title":"fn to_s: String"},{"location":"builtins/#fn-len-integer","text":"Return the number of Byte values within self .","title":"fn len: Integer"},{"location":"builtins/#fn-slicestart-integer-0-stop-integer-1-bytestring","text":"Create a new ByteString copying a section of self from start to stop. If a negative index is given, it is treated as an offset from the end of self , with -1 being considered the last element.","title":"fn slice(start: Integer = 0, stop: Integer = -1): ByteString"},{"location":"builtins/#class-coroutine","text":"A Coroutine is similar to a Function , except that it can also yield values at different points along its lifetime. Every Coroutine has a callstack that belongs to it, as well as an exception state. A Coroutine 's status can be discovered by one of the is_ methods. The Coroutine type takes two types. The first is the type that the Coroutine will be returning or yielding. The second is the type that the Coroutine takes as a message. A Coroutine can take empty Unit messages for simplicity, or a more interesting type if a more bidirectional kind of messaging is wanted. A Coroutine can get the value resumed using Coroutine.receive while within the Coroutine . The first argument of a Function to be made a Coroutine is always the Coroutine itself. If the Function specifies extra arguments, those arguments are to be passed to the intermediate result of Coroutine.create .","title":"Class Coroutine"},{"location":"builtins/#sta-fn-buildfun-functioncoroutinea-b-coroutinea-b","text":"Build a new Coroutine that wraps over the Function provided.","title":"sta fn build(fun: Function(Coroutine[A, B])): Coroutine[A, B]"},{"location":"builtins/#sta-fn-build_with_valuefun-functioncoroutinea-b-c-value-c-coroutinea-b","text":"Build a new Coroutine that wraps over the Function provided. The base Function has the second argument set to 'value' exactly once before any resumption takes place. This method is provided so that a Coroutine can take an extra value (perhaps a Tuple ) without needing to be a closure.","title":"sta fn build_with_value(fun: Function(Coroutine[A, B], C), value: C): Coroutine[A, B]"},{"location":"builtins/#fn-is_done-boolean","text":"Returns true if the Coroutine has returned a value instead of yielding, false otherwise.","title":"fn is_done: Boolean"},{"location":"builtins/#fn-is_failed-boolean","text":"Returns true if the Coroutine raised an exception, false otherwise.","title":"fn is_failed: Boolean"},{"location":"builtins/#fn-is_waiting-boolean","text":"Returns true if the Coroutine is ready to be resumed, false otherwise.","title":"fn is_waiting: Boolean"},{"location":"builtins/#fn-is_running-boolean","text":"Returns true if the Coroutine is running, false otherwise. Note that this does not mean that the Coroutine is the one currently running, only that it is running.","title":"fn is_running: Boolean"},{"location":"builtins/#fn-receive-b","text":"This function returns the value that the Coroutine is holding, so long as the Coroutine is the one currently running. The value stored by the Coroutine is initially the first argument sent to the intermediate builder. Following that, it is the last value that was sent to the Coroutine using Coroutine.resume_with .","title":"fn receive: B"},{"location":"builtins/#sta-fn-resumeself-coroutinea-unit-optiona","text":"Attempt to resume the Coroutine provided. A Coroutine can be resumed only if it is currently in the 'waiting' state. This function does not send a value to the Coroutine which is why it requires the second parameter to be Unit . If the Coroutine is suspended and yields a value, the result is a Some of that value. Otherwise, this returns None . Note that if a Coroutine returns a value instead of yielding, the value is ignored and the result is None .","title":"sta fn resume(self: Coroutine[A, Unit]): Option[A]"},{"location":"builtins/#fn-resume_withvalue-b-optiona","text":"Attempt to resume the Coroutine provided. A Coroutine can be resumed only if it is currently in the 'waiting' state. This function includes a value for the Coroutine to store. The value is stored only if the Coroutine is resumed. If stored, the old value is ejected from the Coroutine provided. If the Coroutine is suspended and yields (or returns) a value, the result is a Some of that value. Otherwise, this returns None .","title":"fn resume_with(value: B): Option[A]"},{"location":"builtins/#yieldvalue-a","text":"Yield value from the Coroutine given. Control returns to whatever invoked self . Raises RuntimeError if self is the current Coroutine , or within a foreign call.","title":"yield(value: A)"},{"location":"builtins/#class-double","text":"","title":"Class Double"},{"location":"builtins/#fn-to_i-integer_2","text":"Convert a Double to an Integer .","title":"fn to_i: Integer"},{"location":"builtins/#class-file","text":"The File class provides a wrapper over a C FILE * struct. A File is closed automatically when a scope exits (though not immediately). However, it is also possible to manually close a File .","title":"Class File"},{"location":"builtins/#fn-close","text":"Close self if it is open, or do nothing if already closed. Note that for standard streams, this marks the File as closed, but does not actually close the stream.","title":"fn close"},{"location":"builtins/#fn-each_linefun-functionbytestring","text":"Read each line of text from self , passing it down to fun for processing. Raises IOError if self is not open for reading, or is closed.","title":"fn each_line(fun: Function(ByteString))"},{"location":"builtins/#fn-flush","text":"This function writes all buffered data associated with the File provided. Raises IOError if self is closed or not open for writing.","title":"fn flush"},{"location":"builtins/#sta-fn-openpath-string-mode-string-file","text":"Attempt to open path using the mode given. mode may be one of the following: - r : read only, must exist - w : write only - a : append, create if not exist - r+ : read+write, must exist - w+ : read+write, creates an empty file if needed. - a+ : read+append Raises IOError if unable to open path , or an invalid mode is provided.","title":"sta fn open(path: String, mode: String): File"},{"location":"builtins/#fn-printdata-a","text":"Attempt to write the contents of data to the file provided. data is written with a newline at the end. Raises IOError if self is closed or is not open for writing.","title":"fn print(data: A)"},{"location":"builtins/#fn-readsize-integer-1-bytestring","text":"Read size bytes from self . If size is negative, then the full contents of self are read. This stops if either size bytes are read, or the end of self is reached. Raises IOError if self is not open for reading, or is closed.","title":"fn read(size: *Integer = -1): ByteString"},{"location":"builtins/#fn-read_line-bytestring","text":"Attempt to read a line of text from self . When end of file reached, returns b\"\" . Raises IOError if self is not open for reading, or is closed.","title":"fn read_line: ByteString"},{"location":"builtins/#fn-writedata-a","text":"Attempt to write the contents of data to the file provided. Raises IOError if self is closed or is not open for writing.","title":"fn write(data: A)"},{"location":"builtins/#class-function","text":"The Function class represents a block of code to be called, which may or may not produce a value. Function values are first-class, and can be passed around as arguments, placed into a List , and so on.","title":"Class Function"},{"location":"builtins/#class-hash","text":"The Hash class provides a mapping between a key and a value. Hash values can be created through [key1 => value1, key2 => value2, ...] . When writing a Hash , the key is the first type, and the value is the second. [1 => \"a\", 2 => \"b\", 3 => \"c\"] would therefore be written as Hash[Integer, String] .","title":"Class Hash"},{"location":"builtins/#fn-clear","text":"Removes all pairs currently present within self . Raises RuntimeError if self is currently being iterated over.","title":"fn clear"},{"location":"builtins/#fn-deletekey-a","text":"Attempt to remove key from self . If key is not present within self raises KeyError . Raises RuntimeError if self is currently being iterated over.","title":"fn delete(key: A)"},{"location":"builtins/#fn-each_pairfun-functiona-b","text":"Iterate through each pair that is present within self . For each of the pairs, call fun with the key and value of each pair.","title":"fn each_pair(fun: Function(A, B))"},{"location":"builtins/#fn-getkey-a-optionb","text":"Attempt to find key within self . If key is present, then a Some containing the associated value is returned. Otherwise, this returns None .","title":"fn get(key: A): Option[B]"},{"location":"builtins/#fn-has_keykey-a-boolean","text":"Return true if key is present within self , false otherwise.","title":"fn has_key(key: A): Boolean"},{"location":"builtins/#fn-keys-lista","text":"Construct a List containing all values that are present within self . There is no guarantee of the ordering of the resulting List .","title":"fn keys: List[A]"},{"location":"builtins/#fn-map_valuesfun-functionb-c-hasha-c","text":"This iterates through self and calls fun for each element present. The result of this function is a newly-made Hash where each value is the result of the call to fun .","title":"fn map_values(fun: Function(B =&gt; C)): Hash[A, C]"},{"location":"builtins/#fn-mergeothers-hasha-b-hasha-b","text":"Create a new Hash that holds the result of self and each Hash present within others. When duplicate elements are found, the value of the right-most Hash wins.","title":"fn merge(others: Hash[A, B]...): Hash[A, B]"},{"location":"builtins/#fn-rejectfun-functiona-b-boolean-hasha-b","text":"This calls fun for each element present within self . The result of this function is a newly-made Hash containing all values for which fun returns false .","title":"fn reject(fun: Function(A, B =&gt; Boolean)): Hash[A, B]"},{"location":"builtins/#fn-selectfun-functiona-b-boolean-hasha-b","text":"This calls fun for each element present within self . The result of this function is a newly-made Hash containing all values for which fun returns true .","title":"fn select(fun: Function(A, B =&gt; Boolean)): Hash[A, B]"},{"location":"builtins/#fn-len-integer_1","text":"Returns the number of key-value pairs present within self .","title":"fn len: Integer"},{"location":"builtins/#class-integer","text":"The Integer class is s native numeric type, represented with C int64_t .","title":"Class Integer"},{"location":"builtins/#fn-to_bool-boolean","text":"Converts an Integer to a Boolean .","title":"fn to_bool: Boolean"},{"location":"builtins/#fn-to_b-byte","text":"Convert an Integer to a Byte , truncating the value if necessary.","title":"fn to_b: Byte"},{"location":"builtins/#fn-to_d-double","text":"Converts an Integer to a Double .","title":"fn to_d: Double"},{"location":"builtins/#fn-to_s-string_2","text":"Convert an Integer to a String using base-10.","title":"fn to_s: String"},{"location":"builtins/#class-list","text":"The List class represents a container of a given type, written as List[<inner type>] . A List value can be accessed through a positive index or a negative one (with negative indexes being an offset from the end). Attempting to access an invalid index will raise IndexError .","title":"Class List"},{"location":"builtins/#fn-appendlist-lista-lista","text":"Append list to end of self . Returns modified list.","title":"fn append(list: List[A]): List[A]"},{"location":"builtins/#fn-clear_1","text":"Removes all elements present within self . No error is raised if self is being iterated over.","title":"fn clear"},{"location":"builtins/#fn-countfun-functiona-boolean-integer","text":"This calls fun for each element within self . The result of this function is the number of times that fun returns true .","title":"fn count(fun: Function(A =&gt; Boolean)): Integer"},{"location":"builtins/#fn-delete_atindex-integer","text":"Attempts to remove index from the List . If index is negative, then it is considered an offset from the end of the List . Raises IndexError if index is out of range.","title":"fn delete_at(index: Integer)"},{"location":"builtins/#fn-eachfun-functiona-lista","text":"Calls fun for each element within self . The result of this function is self , so that this method can be chained with others.","title":"fn each(fun: Function(A)): List[A]"},{"location":"builtins/#fn-each_indexfun-functioninteger-lista","text":"Calls fun for each element within self . Rather than receive the elements of self , fun instead receives the index of each element.","title":"fn each_index(fun: Function(Integer)): List[A]"},{"location":"builtins/#fn-foldstart-a-fun-functiona-a-a-a","text":"This calls fun for each element present within self . The first value sent to fun is initially start, but will later be the result of fun . Therefore, the value as it accumulates can be found in the first value sent to fun . The result of this function is the result of doing an accumulation on each element within self .","title":"fn fold(start: A, fun: Function(A, A =&gt; A)): A"},{"location":"builtins/#sta-fn-fillcount-integer-fun-functioninteger-a-lista","text":"Generate a List of count items using fun . This calls fun with an index that starts at 0 and proceeds until count , and does not include count . If count is 0 or negative, then the resulting List will be empty.","title":"sta fn fill(count: Integer, fun: Function(Integer =&gt; A)): List[A]"},{"location":"builtins/#fn-getindex-integer-optiona","text":"Attempt to find index within self . If the index is within self , then the value is returned within a Some . Otherwise, this returns None .","title":"fn get(index: Integer): Option[A]"},{"location":"builtins/#fn-insertindex-integer-value-a","text":"Attempt to insert value at index within self . If index is negative, then it is treated as an offset from the end of self . Raises IndexError if index is not within self .","title":"fn insert(index: Integer, value: A)"},{"location":"builtins/#fn-joinseparator-string-string","text":"Create a String consisting of the elements of self joined with separator . The elements of self are converted to a String as if they were interpolated. If self is empty, then the result is an empty String .","title":"fn join(separator: *String = \"\"): String"},{"location":"builtins/#fn-mapfun-functiona-b-listb","text":"This calls fun on each element within self . The result of this function is a newly-made List containing the results of fun .","title":"fn map(fun: Function(A =&gt; B)): List[B]"},{"location":"builtins/#fn-pop-a","text":"Attempt to remove and return the last element within self . Raises IndexError if self is empty.","title":"fn pop: A"},{"location":"builtins/#fn-pushvalue-a-lista","text":"Add value to the end of self .","title":"fn push(value: A): List[A]"},{"location":"builtins/#fn-rejectfun-functiona-boolean-lista","text":"This calls fun for each element within self . The result is a newly-made List holding each element where fun returns false .","title":"fn reject(fun: Function(A =&gt; Boolean)): List[A]"},{"location":"builtins/#sta-fn-repeatcount-integer-value-a-lista","text":"This creates a new List that contains value repeated count times. Raises ValueError if count is less than 1.","title":"sta fn repeat(count: Integer, value: A): List[A]"},{"location":"builtins/#fn-selectfun-functiona-boolean-lista","text":"This calls fun for each element within self . The result is a newly-made List holding each element where fun returns true .","title":"fn select(fun: Function(A =&gt; Boolean)): List[A]"},{"location":"builtins/#fn-len-integer_2","text":"Returns the number of elements that are within self .","title":"fn len: Integer"},{"location":"builtins/#fn-shift-a","text":"This attempts to remove the last element from self and return it. Raises ValueError if self is empty.","title":"fn shift: A"},{"location":"builtins/#fn-slicestart-integer-0-stop-integer-1-lista","text":"Create a new List copying a section of self from start to stop . If a negative index is given, it is treated as an offset from the end of self , with -1 being considered the last element. Raises IndexError if start or stop is out of range or the start is larger than the stop .","title":"fn slice(start: Integer = 0, stop: Integer = -1): List[A]"},{"location":"builtins/#fn-unshiftvalue-a-lista","text":"Inserts value at the front of self , moving all other elements to the right.","title":"fn unshift(value: A): List[A]"},{"location":"builtins/#fn-zipothers-list1-listtuplea-1","text":"This creates a List that contains a merger of the values within each of the elements in others and self . The $1 type is a special type that allows this method to work with any number of List values.","title":"fn zip(others: List[$1]...): List[Tuple[A, $1]]"},{"location":"builtins/#class-string","text":"The String class provides a wrapper over a C char * . The String class is guaranteed to have a single \\0 terminator. Additionally, a String is guaranteed to always be valid utf-8. The methods on the String class treat the underlying String as being immutable, and thus always create a new String instead of modifying the existing one.","title":"Class String"},{"location":"builtins/#fn-char_atindex-integer-byte","text":"Returns a characted at index in the self . If index is negative, then it is considered an offset from the end of the self . Raises IndexError if index is not within self .","title":"fn char_at(index: Integer): Byte"},{"location":"builtins/#fn-formatargs-1-string","text":"This creates a new String by processing self as a format. Format specifiers must be between braces ( {} ), and must be between 0 and 99 . Each format specifier is replaced with the according argument, with the first argument being at 0, the second at 1, and so on. Raises ValueError if a format specifier is malformed or has too many digits. Raises IndexError if the format specifier specifies an out-of-range argument.","title":"fn format(args: $1...): String"},{"location":"builtins/#fn-ends_withend-string-boolean","text":"Checks if self ends with end .","title":"fn ends_with(end: String): Boolean"},{"location":"builtins/#fn-findneedle-string-start-integer-0-optioninteger","text":"Check for needle being within self . By default, this begins at the start of self . If start is non-zero, then the search begins start bytes away from the beginning of self . If start lies within the middle of a utf-8 codepoint, then None is returned. If needle is found, the result is a Some holding the index. Otherwise, this returns None .","title":"fn find(needle: String, start: *Integer = 0): Option[Integer]"},{"location":"builtins/#fn-is_alnum-boolean","text":"Return true if self has only alphanumeric( [a-zA-Z0-9]+ ) characters, false otherwise.","title":"fn is_alnum: Boolean"},{"location":"builtins/#fn-is_alpha-boolean","text":"Return true if self has only alphabetical( [a-zA-Z]+ ) characters, false otherwise.","title":"fn is_alpha: Boolean"},{"location":"builtins/#fn-is_digit-boolean","text":"Return true if self has only digit( [0-9]+ ) characters, false otherwise.","title":"fn is_digit: Boolean"},{"location":"builtins/#fn-is_space-boolean","text":"Returns true if self has only space( \" \\t\\r\\n\" ) characters, false otherwise.","title":"fn is_space: Boolean"},{"location":"builtins/#fn-lower-string","text":"Checks if any characters within self are within [ A-Z] . If so, it creates a new String with [A-Z] replaced by [a-z] . Otherwise, self is returned.","title":"fn lower: String"},{"location":"builtins/#fn-lstripto_strip-string-string","text":"This walks through self from left to right, stopping on the first utf-8 chunk that is not found within to_strip . The result is a newly-made copy of self without the elements within to_strip at the front.","title":"fn lstrip(to_strip: String): String"},{"location":"builtins/#fn-to_i-integer_3","text":"Attempts to convert self into an Integer . self is parsed as a base-10 encoded value. If the value is not a valid Integer , ValueError will raised.","title":"fn to_i: Integer"},{"location":"builtins/#fn-to_d-double_1","text":"Attempts to convert self into an Double . self is parsed as a base-10 encoded value. If the value is not a valid Double , ValueError will raised.","title":"fn to_d: Double"},{"location":"builtins/#fn-replaceneedle-string-new-string-string","text":"Create a new String consisting of every needle replaced with new .","title":"fn replace(needle: String, new: String): String`"},{"location":"builtins/#fn-rstripto_strip-string-string","text":"This walks through self from right to left, stopping on the first utf-8 chunk that is not found within to_strip . The result is a newly-made copy of self without the elements of to_strip at the end.","title":"fn rstrip(to_strip: String): String"},{"location":"builtins/#fn-len-integer_3","text":"Return the number of bytes in self . This is equivalent to ByteString.len .","title":"fn len: Integer"},{"location":"builtins/#fn-slicestart-integer-0-stop-integer-1-string","text":"Create a new String copying a section of self from start to stop . This function works using byte indexes into the String value. If a negative index is given, it is treated as an offset from the end of self, with -1 being considered the last element. Raises IndexError if either start or stop is out of range or if the start is larger than the stop . Raises ValueError if the resulting slice would not be valid utf-8.","title":"fn slice(start: Integer = 0, stop: Integer = -1): String"},{"location":"builtins/#fn-splitsplit_by-string-liststring","text":"This attempts to split self using split_by , with a default value of a single space. Raises ValueError if split_by is empty.","title":"fn split(split_by: *String = \" \"): List[String]"},{"location":"builtins/#fn-starts_withwith-string-boolean","text":"Checks if self starts with with .","title":"fn starts_with(with: String): Boolean"},{"location":"builtins/#fn-stripto_strip-string-string","text":"This walks through self from right to left, and then from left to right. The result of this is a newly-made String without any elements within to_strip at either end.","title":"fn strip(to_strip: String): String"},{"location":"builtins/#fn-to_bs-bytestring","text":"Produce a copy of self as a ByteString .","title":"fn to_bs: ByteString"},{"location":"builtins/#fn-trim-string","text":"Checks if self starts or ends with any of \" \\t\\r\\n\" . If it does, then a new String is made with spaces removed from both sides. If it does not, then this returns self .","title":"fn trim: String"},{"location":"builtins/#fn-upper-string","text":"Checks if any characters within self are within [a-z] . If so, it creates a new String with [a-z] replaced by [A-Z] . Otherwise, self is returned.","title":"fn upper: String"},{"location":"builtins/#class-tuple","text":"The Tuple class provides a fixed-size container over a set of types. Tuple is ideal for situations where a variety of data is needed, but a class is too complex. Tuple literals are created by <[value1, value2, ...]> . Member of the Tuple class can be accessed through subscripts. Unlike List , Tuple does not support negative indexes.","title":"Class Tuple"},{"location":"builtins/#enum-option-optiona-somea-none","text":"The Option type presents a way to hold either a value of A , or None , with None being valid for any Option . A common use for this is as a return type for functions that may fail, but have no meaningful error message.","title":"Enum Option Option[A] { Some(A), None}"},{"location":"builtins/#fn-andother-optionb-optionb","text":"If self is a Some , this returns other . Otherwise, this returns None .","title":"fn and(other: Option[B]): Option[B]"},{"location":"builtins/#fn-and_thenfun-functiona-optionb-optionb","text":"If self is a Some , this calls fun with the value within the Some . The result is the result of the Option returned by fun . Otherwise, this returns None .","title":"fn and_then(fun: Function(A =&gt; Option[B])): Option[B]"},{"location":"builtins/#fn-is_none-boolean","text":"If self is a Some , this returns false . Otherwise, this returns true .","title":"fn is_none: Boolean"},{"location":"builtins/#fn-is_some-boolean","text":"If self is a Some , this returns true . Otherwise, this returns false .","title":"fn is_some: Boolean"},{"location":"builtins/#fn-mapfun-functiona-b-optionb","text":"If self is a Some , this returns a Some holding the result of fun . Otherwise, this returns None .","title":"fn map(fun: Function(A =&gt; B)): Option[B]"},{"location":"builtins/#fn-oralternate-optiona-optiona","text":"If self is a Some , this returns self . Otherwise, this returns alternate .","title":"fn or(alternate: Option[A]): Option[A]"},{"location":"builtins/#fn-or_elsefun-function-optiona-optiona","text":"If self is a Some , this returns self . Otherwise, this returns the result of calling fun .","title":"fn or_else(fun: Function( =&gt; Option[A])): Option[A]"},{"location":"builtins/#fn-unwrap-a","text":"If self is a Some , this returns the value contained within. Raises ValueError if self is None .","title":"fn unwrap: A"},{"location":"builtins/#fn-unwrap_oralternate-a-a","text":"If self is a Some , this returns the value with self . Otherwise, this returns alternate .","title":"fn unwrap_or(alternate: A): A"},{"location":"builtins/#fn-unwrap_or_elsefun-function-a-a","text":"If self is a Some , this returns the value with self . Otherwise, this returns the result of calling fun .","title":"fn unwrap_or_else(fun: Function( =&gt; A)): A"},{"location":"builtins/#enum-result-resulta-b-failurea-successb","text":"Result is an enum that holds either a Failure or Success . This enum is for situations where the function that fails has an error message to deliver.","title":"Enum Result Result[A, B] { Failure(A), Success(B)}"},{"location":"builtins/#fn-failure-optiona","text":"If self contains a Failure , produces a Some(A) . If self contains a Right , produces None .","title":"fn failure: Option[A]"},{"location":"builtins/#fn-is_failure-boolean","text":"Return true if self contains a Failure , false otherwise.","title":"fn is_failure: Boolean"},{"location":"builtins/#fn-is_success-boolean","text":"Return true if self contains a Success , false otherwise.","title":"fn is_success: Boolean"},{"location":"builtins/#fn-success-optionb","text":"If self contains a Failure , produces a None . If self contains a Success , produces Right(B) .","title":"fn success: Option[B]"},{"location":"builtins/#function-sayln-saylnvalue-a","text":"Write value to stdout , plus a newline ( \"\\n\" ).","title":"Function sayln sayln(value: A)"},{"location":"builtins/#function-say-sayvalue-a","text":"Write value to stdout (without a newline).","title":"Function say say(value: A)"},{"location":"builtins/#function-input-inputprompt-string-bytestring","text":"Write value to stdout , then read input from stdin .","title":"Function input input(prompt: *String): ByteString"},{"location":"builtins/#function-range-rangestart-integer-0-end-integer","text":"Build list contains all numbers from start to end (inclusive).","title":"Function range range(start: *Integer = 0, end: Integer)"},{"location":"builtins/#function-calltrace-calltrace-liststring","text":"Returns a List with one String for each function that is currently entered.","title":"Function calltrace calltrace: List[String]"},{"location":"builtins/#variable-stdin-stdin-file","text":"Provides a wrapper around the stdin .","title":"Variable stdin stdin: File"},{"location":"builtins/#variable-stderr-stderr-file","text":"Provides a wrapper around the stderr .","title":"Variable stderr stderr: File"},{"location":"builtins/#variable-stdout-stdout-file","text":"Provides a wrapper around the stdout .","title":"Variable stdout stdout: File"},{"location":"builtins/#random","text":"The random package provides access to a pseudo-random number generation.","title":"random"},{"location":"builtins/#class-random","text":"The Random class provides access to the random number generator. Each instance is completely separate from all others. The constructor for this class takes a seed. If the seed provided is 0 or less, then the current time is used instead.","title":"Class Random"},{"location":"builtins/#fn-seed-integer-0-random","text":"","title":"fn (seed: *Integer = 0): Random"},{"location":"builtins/#fn-betweenlower-integer-upper-integer-integer","text":"Generate a random Integer value between lower and upper . Raises ValueError is raised if the range is empty, or reversed.","title":"fn between(lower: Integer, upper: Integer): Integer"},{"location":"builtins/#sys","text":"","title":"sys"},{"location":"builtins/#fn-listdirpath-string-liststring","text":"Returns list of files in path . Raises IOError if path is not exists or accessible.","title":"fn listdir(path: String): List[String]"},{"location":"builtins/#fn-rmdirpath-string-boolean","text":"Removes a directory whose name is given by path . The directory shall be removed only if it is an empty directory. Raises IOError if path is not exists or accessible, otherwise returns true .","title":"fn rmdir(path: String): Boolean"},{"location":"builtins/#fn-removepath-string-boolean","text":"Removes a file whose name is given by path . Raises IOError if path is not exists or accessible, otherwise returns true .","title":"fn remove(path: String): Boolean"},{"location":"builtins/#fn-mkdirpath-string-boolean","text":"Creates a file whose name is given by path . Raises IOError if path is not a valid path name, otherwise returns true .","title":"fn mkdir(path: String): Boolean"},{"location":"builtins/#fn-existspath-string-boolean","text":"Returns true , if path is a existing file or directory, false otherwise.","title":"fn exists(path: String): Boolean"},{"location":"builtins/#fn-is_dirpath-string-boolean","text":"Returns true , if path is a existing directory, false otherwise.","title":"fn is_dir(path: String): Boolean"},{"location":"builtins/#fn-is_filepath-string-boolean","text":"Returns true , if path is a existing file, false otherwise.","title":"fn is_file(path: String): Boolean"},{"location":"builtins/#fn-exitexit_code-integer","text":"Stop execution of the program and return code exit_code .","title":"fn exit(exit_code: *Integer)"},{"location":"builtins/#fn-getenvname-string-optionstring","text":"Search the environment for name , returning either a Some with the contents, or None .","title":"fn getenv(name: String): Option[String]"},{"location":"builtins/#fn-setenvname-string-value-string-boolean","text":"Set environment variable name to value , on success return true , false otherwise.","title":"fn setenv(name: String, value: String): Boolean"},{"location":"builtins/#fn-recursion_limit-integer","text":"Return the current recursion limit.","title":"fn recursion_limit: Integer"},{"location":"builtins/#fn-set_recursion_limitlimit-integer","text":"Attempt to set limit as the maximum recursion limit. Raises ValueError if limit is lower than the current recursion depth or an negative value.","title":"fn set_recursion_limit(limit: Integer)"},{"location":"builtins/#variable-argv-argv-liststring","text":"This contains arguments sent to the program through the command-line. If interpreter was not invoked from the command-line then this is empty.","title":"Variable argv argv: List[String]"},{"location":"builtins/#time","text":"The time package provides access to basic time information on the system.","title":"time"},{"location":"builtins/#class-time","text":"Instances of this class represent a single point in time. This class also includes static methods to provide a few extra features.","title":"Class Time"},{"location":"builtins/#sta-fn-clock-double","text":"Returns the number of seconds of CPU time the interpreter has used.","title":"sta fn clock: Double"},{"location":"builtins/#sta-fn-now-time","text":"Returns a Time instance representing the current system time.","title":"sta fn now: Time"},{"location":"builtins/#fn-to_sformat-string-y-m-d-hms-z-string","text":"Return a String representation of a Time instance in format format.","title":"fn to_s(format: *String = \"%Y-%m-%d %H:%M:%S %z\"): String"},{"location":"builtins/#fn-since_epoch-integer","text":"Returns the value of self as a number of seconds since the epoch.","title":"fn since_epoch: Integer"},{"location":"builtins/#hash","text":"The hash provides access to hash-functions, e.g. md5 .","title":"hash"},{"location":"builtins/#fn-md5input-string-string","text":"Returns a md5 hash from input .","title":"fn md5(input: String): String"},{"location":"builtins/#fn-sha1input-string-string","text":"Returns a sha1 hash from input .","title":"fn sha1(input: String): String"}]}